{
  "name": "grunt-neuter",
  "version": "0.6.0",
  "description": "Builds source files in the order you require.",
  "main": "Gruntfile.js",
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:trek/grunt-neuter.git"
  },
  "keywords": [
    "build",
    "grunt",
    "concat",
    "gruntplugin"
  ],
  "author": {
    "name": "Trek Glowacki",
    "email": "trek.glowacki@gamil.com"
  },
  "license": "MIT",
  "dependencies": {
    "glob": "~3.2.3",
    "source-map": "~0.1.22"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.2.0",
    "grunt-contrib-nodeunit": "0.1.2",
    "grunt-contrib-clean": "~0.4.0",
    "grunt-contrib-internal": "~0.4.3"
  },
  "readme": "# grunt-neuter [![Build Status](https://travis-ci.org/trek/grunt-neuter.png)](https://travis-ci.org/trek/grunt-neuter)\n\n\n> Concatenate files in the order you `require`.\n\n## Getting Started\nIf you haven't used [grunt][] before, be sure to check out the [Getting Started][] guide, as it explains how to create a [gruntfile][Getting Started] as well as install and use grunt plugins. Once you're familiar with that process, install this plugin with this command:\n\n```shell\nnpm install grunt-neuter --save-dev\n```\nor for the latest version\n\n```shell\nnpm install git://github.com/trek/grunt-neuter.git --save-dev\n```\n\nThen include the tasks in your project's Gruntfile\n\n```javascript\ngrunt.loadNpmTasks('grunt-neuter');\n```\n\n\n[grunt]: http://gruntjs.com/\n[Getting Started]: https://github.com/gruntjs/grunt/wiki/Getting-started\n\n\n## Neuter task\n_Run this task with the `grunt neuter` command._\n\n_This task is a [multi task](https://github.com/gruntjs/grunt/wiki/Configuring-tasks) so any targets, files and options should be specified according to the [multi task](https://github.com/gruntjs/grunt/wiki/Configuring-tasks) documentation._\n\nUse a neutering task for\n\n  1. Breaking up a project into files: some applications are easier to reason about\n     when their source is divided into files and organzied with directories\n\n  2. Keep intra-project dependency management inline: rather than have to track\n     and updated files and their order in a Make/Cake/Rakefile or a JSON object.\n\n  3. Have files separated in debugging, combined in production: When using\n     good development tools you want to easily map your debugging efforts to\n     a specific file, not read through one giant file.\n\n  4. Not need a dependency management library deployed: for applications\n     deployed as a single file the benefits of modular file loaders like\n     [require.js](http://requirejs.org/) is minimized.\n\nNeuter is based on the [Rake pipline web-filter of the same name](https://github.com/wycats/rake-pipeline-web-filters)\n\n## Example\nGiven the following files:\n\n`a.js`\n```javascript\nrequire('b');\n\nvar myVariable = 'hello';\n```\n\n`b.js`\n```javascript\nvar variableFromB = 'b';\nwindow.availableEverywhere = true;\n```\n\nResulting output would be\n\n```javascript\n(function(){\n  var variableFromB = 'b';\n  window.availableEverywhere = true;\n})();\n\n(function(){\n\n  var myVariable = 'hello';\n})();\n```\n\n## Relative Paths\nRelative paths using a dot to indicate the file's current directory are valid as well:\n\n`a.js`\n```javascript\nrequire('dir/b');\n\nvar variableFromA = 'a';\n```\n\n`dir/b.js`\n```javascript\nrequire('./c');\n\nvar variableFromB = 'b';\n```\n\n`dir/c.js`\n```javascript\nvar variableFromC = 'c';\n```\n\nOutputs\n\n```javascript\n(function(){\n  var variableFromC = 'c';\n})();\n\n(function(){\n\n  var variableFromB = 'b';\n})();\n\n(function(){\n\n  var variableFromA = 'a';\n})();\n```\n\nNote that directory traversal using `../` is **not** supported.\n\n## Example Gruntfile Use\n```javascript\ngrunt.initConfig({\n  neuter: {\n    application: {\n      src: 'tmp/application.js',\n      dest: 'app/index.js'\n    }\n  }\n});\n```\n\nor\n\n```javascript\ngrunt.initConfig({\n  neuter: {\n      'tmp/application.js' :'app/index.js'\n  }\n});\n```\n\n\n\n### Options\n\n### template\nType: `String`\n\nDefault: `\"(function){ {%= src %} })();\"`\n\nThe wrapper around your code. Defaults to a closure-style function so locally declared variables\nwon't leak into the global scope. The text of your source JavaScript file is available as `src`\nwithin a template.\n\n### basePath\nType: `String`\n\nDefault: `\"\"`\n\nSpecifying a base path allows you to omit said portion of the filepath from your require statements. For example: when using `basePath: \"lib/js/\"` in your task options, `require(\"lib/js/file.js\");` can instead be written as `require(\"file.js\");`. Note that the trailing slash *must* be included.\n\n### filepathTransform\nType: `Function`\n\nDefault: `function(filepath){ return filepath; }`\n\nSpecifying a filepath transform allows you to control the path to the file that actually gets concatenated. For example, when using `filepathTransform: function(filepath){ return 'lib/js/' + filepath; }` in your task options, `require(\"lib/js/file.js\");` can instead be written as `require(\"file.js\");` (This achieves the same result as specifying `basePath: \"lib/js/\"`). When used in conjunction with the `basePath` option, the base path will be prepended to the `filepath` argument and a second argument will be provided that is the directory of the file **without** the `basePath`.\n\n### includeSourceURL\nType: `Boolean`\n\nDefault: `false`\n\nIncludes the path to your source JavaScript file as `//@ sourceURL=\"path/to/my/file.js\"` for\n[nicer debugging](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl). Note that this wraps your source JavaScript file (as a string) with `eval` and should not be used in prouduction.\n\n### separator\nType: `String`\n\nDefault: `\"\\n\"`\n\nNeutered files will be joined on this string. If you're post-processing concatenated JavaScript files with a minifier, you may need to use a semicolon `';'` as the separator although the semicolon at the end of the template should suffice.\n\n### skipFiles\nType: `Array`\n\nDefault: `[]`\n\nA list of files being required that should not be checked for further require statements.\nUseful for libraries that support other module building methods and leave their requires\naround in a way that isn't meaningful to neutering.\n\n### process\nType: `Boolean` `Object` `Function` Default: `false`\n\nProcess source files before concatenating, either as [templates](https://github.com/gruntjs/grunt/wiki/grunt.template) or with a custom function (similar to [grunt-contrib-concat](https://github.com/gruntjs/grunt-contrib-concat)). When using grunt for templating, the delimiters default to neuter's own special type (`{% %}`), which helps avoid errors when requiring libraries like [Underscore](http://underscorejs.org/) or [Lo-Dash](http://lodash.com/).\n\n* `false` - No processing will occur.\n* `true` - Process source files using [grunt.template.process][] without any data.\n* `options` object - Process source files using [grunt.template.process][], using the specified options.\n* `function(src, filepath)` - Process source files using the given function, called once for each file. The returned value will be used as source code.\n\n_(Default processing options are explained in the [grunt.template.process][] documentation)_\n\n  [grunt.template.process]: https://github.com/gruntjs/grunt/wiki/grunt.template#grunttemplateprocess\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/trek/grunt-neuter/issues"
  },
  "homepage": "https://github.com/trek/grunt-neuter",
  "_id": "grunt-neuter@0.6.0",
  "_from": "grunt-neuter@"
}
